/****************************************************************************
**
** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the Qt Linguist of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** GNU Lesser General Public License Usage
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** appearing in the file LICENSE.LGPL included in the packaging of this
** file. Please review the following information to ensure the GNU Lesser
** General Public License version 2.1 requirements will be met:
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU General
** Public License version 3.0 as published by the Free Software Foundation
** and appearing in the file LICENSE.GPL included in the packaging of this
** file. Please review the following information to ensure the GNU General
** Public License version 3.0 requirements will be met:
** http://www.gnu.org/copyleft/gpl.html.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

//
//  W A R N I N G
//  -------------
//
// This file is not part of the Qt API.  It exists for the convenience
// of other Qt classes.  This header file may change from version to
// version without notice, or even be removed.
//
// We mean it.
//

// This file was generated by qlalr - DO NOT EDIT!
#ifndef QSCRIPT_CPP
#define QSCRIPT_CPP

#if defined(ERROR)
#  undef ERROR
#endif

class QScriptGrammar
{
public:
  enum VariousConstants {
    EOF_SYMBOL = 0,
    T_AND = 1,
    T_AND_AND = 2,
    T_AND_EQ = 3,
    T_AUTOMATIC_SEMICOLON = 62,
    T_BREAK = 4,
    T_CASE = 5,
    T_CATCH = 6,
    T_COLON = 7,
    T_COMMA = 8,
    T_CONST = 81,
    T_CONTINUE = 9,
    T_DEBUGGER = 82,
    T_DEFAULT = 10,
    T_DELETE = 11,
    T_DIVIDE_ = 12,
    T_DIVIDE_EQ = 13,
    T_DO = 14,
    T_DOT = 15,
    T_ELSE = 16,
    T_EQ = 17,
    T_EQ_EQ = 18,
    T_EQ_EQ_EQ = 19,
    T_FALSE = 80,
    T_FINALLY = 20,
    T_FOR = 21,
    T_FUNCTION = 22,
    T_GE = 23,
    T_GT = 24,
    T_GT_GT = 25,
    T_GT_GT_EQ = 26,
    T_GT_GT_GT = 27,
    T_GT_GT_GT_EQ = 28,
    T_IDENTIFIER = 29,
    T_IF = 30,
    T_IN = 31,
    T_INSTANCEOF = 32,
    T_LBRACE = 33,
    T_LBRACKET = 34,
    T_LE = 35,
    T_LPAREN = 36,
    T_LT = 37,
    T_LT_LT = 38,
    T_LT_LT_EQ = 39,
    T_MINUS = 40,
    T_MINUS_EQ = 41,
    T_MINUS_MINUS = 42,
    T_NEW = 43,
    T_NOT = 44,
    T_NOT_EQ = 45,
    T_NOT_EQ_EQ = 46,
    T_NULL = 78,
    T_NUMERIC_LITERAL = 47,
    T_OR = 48,
    T_OR_EQ = 49,
    T_OR_OR = 50,
    T_PLUS = 51,
    T_PLUS_EQ = 52,
    T_PLUS_PLUS = 53,
    T_QUESTION = 54,
    T_RBRACE = 55,
    T_RBRACKET = 56,
    T_REMAINDER = 57,
    T_REMAINDER_EQ = 58,
    T_RESERVED_WORD = 83,
    T_RETURN = 59,
    T_RPAREN = 60,
    T_SEMICOLON = 61,
    T_STAR = 63,
    T_STAR_EQ = 64,
    T_STRING_LITERAL = 65,
    T_SWITCH = 66,
    T_THIS = 67,
    T_THROW = 68,
    T_TILDE = 69,
    T_TRUE = 79,
    T_TRY = 70,
    T_TYPEOF = 71,
    T_VAR = 72,
    T_VOID = 73,
    T_WHILE = 74,
    T_WITH = 75,
    T_XOR = 76,
    T_XOR_EQ = 77,

    ACCEPT_STATE = 237,
    RULE_COUNT = 268,
    STATE_COUNT = 466,
    TERMINAL_COUNT = 84,
    NON_TERMINAL_COUNT = 88,

    GOTO_INDEX_OFFSET = 466,
    GOTO_INFO_OFFSET = 1513,
    GOTO_CHECK_OFFSET = 1513
  };

  static const char  *const    spell [];
  static const short             lhs [];
  static const short             rhs [];
  static const short    goto_default [];
  static const short  action_default [];
  static const short    action_index [];
  static const short     action_info [];
  static const short    action_check [];

  static inline int nt_action (int state, int nt)
  {
    const int yyn = action_index [GOTO_INDEX_OFFSET + state] + nt;
    if (yyn < 0 || action_check [GOTO_CHECK_OFFSET + yyn] != nt)
      return goto_default [nt];

    return action_info [GOTO_INFO_OFFSET + yyn];
  }

  static inline int t_action (int state, int token)
  {
    const int yyn = action_index [state] + token;

    if (yyn < 0 || action_check [yyn] != token)
      return - action_default [state];

    return action_info [yyn];
  }
};


const char *const QScriptGrammar::spell [] = {
  "end of file", "&", "&&", "&=", "break", "case", "catch", ":", ";", "continue", 
  "default", "delete", "/", "/=", "do", ".", "else", "=", "==", "===", 
  "finally", "for", "function", ">=", ">", ">>", ">>=", ">>>", ">>>=", "identifier", 
  "if", "in", "instanceof", "{", "[", "<=", "(", "<", "<<", "<<=", 
  "-", "-=", "--", "new", "!", "!=", "!==", "numeric literal", "|", "|=", 
  "||", "+", "+=", "++", "?", "}", "]", "%", "%=", "return", 
  ")", ";", 0, "*", "*=", "string literal", "switch", "this", "throw", "~", 
  "try", "typeof", "var", "void", "while", "with", "^", "^=", "null", "true", 
  "false", "const", "debugger", "reserved word"};

const short QScriptGrammar::lhs [] = {
  85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 
  85, 85, 85, 85, 85, 87, 87, 92, 92, 86,
  86, 89, 89, 93, 93, 93, 93, 94, 94, 94,
  94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 94, 95, 95,
  96, 96, 96, 96, 96, 99, 99, 100, 100, 100,
  100, 98, 98, 101, 101, 102, 102, 103, 103, 103,
  104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
  105, 105, 105, 105, 106, 106, 106, 107, 107, 107,
  107, 108, 108, 108, 108, 108, 108, 108, 109, 109,
  109, 109, 109, 109, 110, 110, 110, 110, 110, 111,
  111, 111, 111, 111, 112, 112, 113, 113, 114, 114,
  115, 115, 116, 116, 117, 117, 118, 118, 119, 119,
  120, 120, 121, 121, 122, 122, 123, 123, 91, 91,
  124, 124, 125, 125, 125, 125, 125, 125, 125, 125,
  125, 125, 125, 125, 90, 90, 126, 126, 127, 127,
  128, 128, 129, 129, 129, 129, 129, 129, 129, 129,
  129, 129, 129, 129, 129, 129, 129, 130, 146, 146,
  145, 145, 131, 131, 147, 147, 148, 148, 150, 150,
  149, 151, 154, 152, 152, 155, 153, 153, 132, 133,
  133, 134, 134, 135, 135, 135, 135, 135, 135, 135,
  136, 136, 136, 136, 137, 137, 137, 137, 138, 138,
  139, 141, 156, 156, 159, 159, 157, 157, 160, 158,
  140, 142, 142, 143, 143, 143, 161, 162, 144, 163,
  97, 167, 167, 164, 164, 165, 165, 168, 84, 169,
  169, 170, 170, 166, 166, 88, 88, 171};

const short QScriptGrammar::rhs [] = {
  1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 
  3, 5, 3, 4, 3, 2, 4, 1, 2, 0,
  1, 3, 5, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 4, 3, 3, 1, 2, 2, 2, 4,
  3, 2, 3, 1, 3, 1, 1, 1, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  1, 3, 3, 3, 1, 3, 3, 1, 3, 3,
  3, 1, 3, 3, 3, 3, 3, 3, 1, 3,
  3, 3, 3, 3, 1, 3, 3, 3, 3, 1,
  3, 3, 3, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 5, 1, 5, 1, 3,
  1, 3, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 3, 0, 1, 1, 3,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 3, 1, 2,
  0, 1, 3, 3, 1, 1, 1, 3, 1, 3,
  2, 2, 2, 0, 1, 2, 0, 1, 1, 2,
  2, 7, 5, 7, 7, 5, 9, 10, 7, 8,
  2, 2, 3, 3, 2, 2, 3, 3, 3, 3,
  5, 5, 3, 5, 1, 2, 0, 1, 4, 3,
  3, 3, 3, 3, 3, 4, 5, 2, 1, 8,
  8, 1, 3, 0, 1, 0, 1, 1, 1, 1,
  2, 1, 1, 0, 1, 0, 1, 2};

const short QScriptGrammar::action_default [] = {
  0, 98, 165, 129, 137, 133, 173, 180, 77, 149,
  179, 187, 175, 125, 0, 176, 263, 62, 177, 178,
  183, 78, 141, 145, 66, 95, 76, 81, 61, 0,
  115, 181, 102, 260, 259, 262, 184, 0, 195, 0,
  249, 0, 8, 9, 0, 5, 0, 264, 2, 0,
  266, 20, 0, 0, 0, 0, 0, 3, 6, 0,
  0, 167, 209, 7, 0, 1, 0, 0, 4, 0,
  0, 196, 0, 0, 0, 185, 186, 91, 0, 174,
  182, 0, 0, 78, 97, 264, 2, 266, 80, 79,
  0, 0, 0, 93, 94, 92, 0, 265, 254, 255,
  0, 252, 0, 253, 0, 256, 257, 0, 258, 251,
  261, 0, 267, 0, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 24,
  42, 43, 44, 45, 46, 26, 47, 48, 25, 49,
  50, 51, 52, 53, 54, 55, 56, 57, 58, 0,
  22, 0, 0, 14, 0, 23, 13, 96, 0, 126,
  0, 0, 0, 0, 116, 0, 0, 0, 0, 0,
  0, 106, 0, 0, 0, 100, 101, 99, 104, 108,
  107, 105, 103, 118, 117, 119, 0, 134, 0, 130,
  69, 0, 0, 0, 71, 60, 59, 0, 0, 70,
  166, 0, 74, 72, 0, 73, 75, 210, 211, 0,
  162, 155, 153, 160, 161, 159, 158, 164, 157, 156,
  154, 163, 150, 0, 138, 0, 0, 142, 0, 0,
  146, 68, 0, 0, 64, 0, 63, 268, 225, 0,
  226, 227, 228, 221, 0, 222, 223, 224, 82, 0,
  0, 0, 0, 0, 214, 215, 171, 169, 131, 139,
  135, 151, 127, 172, 0, 78, 143, 147, 120, 109,
  0, 0, 128, 0, 0, 0, 0, 121, 0, 0,
  0, 0, 0, 113, 111, 114, 112, 110, 123, 122,
  124, 0, 136, 0, 132, 0, 170, 78, 0, 152,
  167, 168, 0, 167, 0, 0, 217, 0, 0, 0,
  219, 0, 140, 0, 0, 144, 0, 0, 148, 207,
  0, 199, 208, 202, 0, 206, 0, 167, 200, 0,
  167, 0, 0, 218, 0, 0, 0, 220, 265, 254,
  0, 0, 256, 0, 250, 0, 241, 0, 0, 0,
  213, 0, 212, 189, 192, 0, 28, 31, 32, 249,
  35, 36, 5, 40, 41, 2, 42, 45, 3, 6,
  167, 7, 49, 1, 51, 4, 53, 54, 55, 56,
  57, 58, 190, 188, 66, 67, 65, 0, 229, 230,
  0, 0, 0, 232, 237, 235, 238, 0, 0, 236,
  237, 0, 233, 0, 234, 191, 240, 0, 191, 239,
  0, 242, 243, 0, 191, 244, 245, 0, 0, 246,
  0, 0, 0, 247, 248, 84, 83, 0, 0, 0,
  216, 0, 0, 0, 231, 0, 21, 0, 18, 20,
  11, 0, 17, 12, 19, 16, 10, 0, 15, 88,
  86, 90, 87, 85, 89, 204, 197, 0, 205, 201,
  0, 203, 193, 0, 194, 198};

const short QScriptGrammar::goto_default [] = {
  29, 28, 437, 435, 113, 112, 14, 2, 436, 111,
  114, 194, 24, 17, 190, 26, 8, 201, 21, 27,
  77, 25, 1, 32, 30, 268, 13, 262, 3, 258,
  5, 260, 4, 259, 22, 266, 23, 267, 9, 261,
  257, 298, 387, 263, 264, 35, 6, 79, 12, 15,
  18, 19, 10, 7, 31, 80, 20, 36, 75, 76, 
  11, 355, 354, 78, 457, 456, 320, 321, 459, 323,
  458, 322, 393, 397, 400, 396, 395, 415, 416, 16,
  100, 107, 96, 99, 106, 108, 33, 0};

const short QScriptGrammar::action_index [] = {
  1349, 60, -84, 153, 43, -1, -84, -84, 152, -84,
  -84, -84, -84, 185, 140, -84, -84, -84, -84, -84,
  -84, 426, 65, 62, 128, 112, -84, -84, -84, 86,
  241, -84, 212, -84, 1349, -84, -84, 132, -84, 130,
  -84, 580, -84, -84, 1269, -84, 45, 56, 59, 42,
  1429, 50, 580, 580, 580, 345, 580, -84, -84, 580,
  580, 580, -84, -84, 25, -84, 580, 580, -84, 46,
  580, -84, 580, 18, 14, -84, -84, -84, 23, -84,
  -84, 580, 580, 64, 116, 35, -84, 1109, -84, -84,
  580, 580, 580, -84, -84, -84, 37, -84, 40, 55,
  2, -84, 36, -84, 27, 1349, -84, 15, 1349, -84,
  -84, 41, 51, -2, -84, -84, -84, -84, -84, -84,
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, 580,
  -84, 1189, 48, -84, 580, -84, -84, 160, 580, 181,
  580, 580, 580, 580, 221, 580, 580, 580, 580, 580,
  580, 212, 580, 580, 580, 67, 75, 83, 212, 212,
  133, 143, 138, 231, 251, 267, 580, 29, 580, 153,
  -84, 1029, 580, 876, -84, -84, -84, 89, 580, -84,
  -84, 96, -84, -84, 580, -84, -84, -84, -84, 580,
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, 580, 26, 580, 580, 66, 73, 580,
  -84, -84, 1029, 580, -84, 95, -84, -84, -84, 58,
  -84, -84, -84, -84, 68, -84, -84, -84, -84, -29,
  10, 580, 93, 77, -84, -84, 949, -84, 32, -16,
  -42, -84, 195, 21, -37, 507, 28, 71, 273, 119,
  -3, 580, 197, 580, 580, 580, 580, 273, 580, 580,
  580, 580, 580, 212, 212, 212, 212, 212, 273, 273,
  273, 580, -74, 580, 4, 580, -84, 298, 580, -84,
  580, 3, -53, 580, -41, 1269, -84, 580, 80, 1269,
  -84, 580, -31, 580, 580, 5, 70, 580, -84, 19,
  88, 12, -84, -84, 580, -84, -28, 580, -84, -40,
  580, -23, 1269, -84, 580, 87, 1269, -84, -8, -6,
  -35, 9, 1349, -14, -84, 1269, -84, 580, 82, 1269,
  -12, 1269, -84, -84, 1269, -39, 123, -19, 149, 8,
  580, 1269, 7, 13, 63, 6, -18, 371, -7, -4,
  730, 33, 11, 24, 580, 31, -13, 580, 22, 580,
  -27, -30, -84, -84, 162, -84, -84, 47, -84, -84,
  580, 114, -21, -84, 34, -84, 30, 100, 580, -84,
  17, 20, -84, -11, -84, 1269, -84, 124, 1269, -84,
  174, -84, -84, 107, 1269, 52, -84, 57, 61, -84,
  53, 16, 38, -84, -84, -84, -84, 580, 106, 1269,
  -84, 580, 90, 1269, -84, 79, 76, 803, -84, 49,
  -84, 653, -84, -84, -84, -84, -84, 81, -84, -84,
  -84, -84, -84, -84, -84, 39, -84, 172, -84, -84,
  580, -84, -84, 54, -84, -84,

  -61, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -5, -88, -88, 28, -88, -88, -88, -88, -88,
  -88, -88, -88, -88, -53, -88, -88, -88, -88, -88,
  -88, 109, -88, -88, -16, -88, -88, -88, -88, -88,
  -8, -88, 33, 135, 66, 79, 81, -88, -88, 104,
  78, 34, -88, -88, -88, -88, 35, 146, -88, -3,
  88, -88, 94, -88, -88, -88, -88, -88, -88, -88,
  -88, 92, 97, -88, -88, -88, -88, -88, -88, -88,
  89, 84, 77, -88, -88, -88, -88, -88, -88, -88,
  -88, -88, -88, -88, -88, -88, -88, -88, -48, -88,
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88,
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, 27,
  -88, 26, -88, -88, 18, -88, -88, -88, 41, -88,
  38, 51, 110, 61, -88, 69, 60, 53, 54, 93,
  125, -88, 124, 129, 122, -88, -88, -88, -88, -88,
  -88, -88, -88, -88, -88, -88, 120, -88, 52, -88,
  -88, 16, 17, 15, -88, -88, -88, -88, 20, -88,
  -88, -88, -88, -88, 23, -88, -88, -88, -88, 37,
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, 99, -88, 103, 24, -88, -88, 25,
  -88, -88, 115, 14, -88, -88, -88, -88, -88, -88,
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, 22, -88, -88, -88, -88, 112, -88, -88, -88,
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, 153, -88, 169, 168, 216, 179, -88, 131, 50,
  42, 70, 82, -88, -88, -88, -88, -88, -88, -88,
  -88, 177, -88, 154, -88, 142, -88, -88, 144, -88,
  127, -88, -88, 126, -88, -24, -88, 46, -88, 29,
  -88, 152, -88, 155, 156, -88, -88, 180, -88, -88,
  -88, -88, -88, -88, 183, -88, -22, 139, -88, -88,
  47, -88, 3, -88, 43, -88, 2, -88, -88, -34,
  -88, -88, -31, -88, -88, 12, -88, 45, -88, 19,
  -88, 21, -88, -88, 13, -88, -88, -88, -88, -88,
  121, 9, -88, -88, -88, -88, -88, 108, -88, -88,
  0, -88, -88, -88, 6, -88, -35, 138, -88, 141,
  -88, -88, -88, -88, 1, -88, -88, -88, -88, -88,
  -6, -88, -88, -88, -88, -88, -69, -88, 10, -88,
  -60, -88, -88, -88, -88, 91, -88, -88, 58, -88,
  -88, -88, -88, -88, -41, -59, -88, -88, -29, -88,
  -88, -88, -45, -88, -88, -88, -88, -1, -88, -43,
  -88, 76, -88, -37, -88, -88, -88, 7, -88, 8,
  -88, -4, -88, -88, -88, -88, -88, -88, -88, -88,
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  11, -88, -88, -56, -88, -88};

const short QScriptGrammar::action_info [] = {
  -46, 319, 293, -26, 351, 271, 431, 311, 303, 427,
  -195, 198, 394, 345, -38, -33, 383, 291, 347, 305,
  414, 330, 398, 101, 300, 341, 319, 405, 339, 295,
  311, -50, 291, 271, 293, 398, 324, 332, -52, 398,
  -25, 344, 342, 334, 404, 250, 251, 390, 149, 256,
  431, -196, 455, 156, 427, 154, 460, 438, 438, 151,
  105, 390, 104, 102, 97, 103, 345, 223, 223, 101,
  109, 414, 418, 98, 186, 188, 422, 317, 347, 414,
  229, 256, 421, 455, 444, 338, 237, 439, 198, 198,
  198, 186, 97, 420, 414, 198, 326, 198, 198, -264,
  81, 198, 0, 198, 204, 188, 88, 81, 389, 388,
  401, 82, 225, 417, 198, 81, 226, 89, 82, 242,
  241, 313, 198, 81, 90, 314, 82, 418, 90, 247,
  246, 408, 198, 0, 82, 440, 0, 0, 255, 254,
  309, 448, 349, 232, 172, 199, 173, 336, 198, 327,
  433, 236, 239, 253, 158, 402, 205, 174, 172, 244,
  173, 239, 233, 172, 193, 173, 429, 191, 172, 91,
  173, 174, 90, 91, 392, 92, 174, 232, 244, 92,
  463, 174, 198, 0, 240, 238, 192, 0, 193, 0,
  0, 245, 243, 240, 238, 0, 233, 0, 193, 160,
  161, 208, 207, 160, 161, 0, 0, 0, 0, 0,
  245, 243, 0, 273, 274, 273, 274, 91, 0, 0,
  0, 0, 0, 92, 0, 0, 162, 163, 0, 0,
  162, 163, 0, 464, 462, 412, 411, 172, 0, 173,
  275, 276, 275, 276, 165, 166, 0, 0, 0, 0,
  174, 0, 167, 168, 165, 166, 169, 0, 170, 0,
  0, 0, 167, 168, 165, 166, 169, 0, 170, 0,
  0, 0, 167, 168, 165, 166, 169, 0, 170, 0,
  0, 0, 167, 168, 0, 0, 169, 0, 170, 0,
  165, 166, 0, 0, 0, 0, 278, 279, 167, 168,
  0, 210, 169, 0, 170, 280, 0, 0, 281, 0,
  282, 211, 0, 0, 0, 212, 0, 0, 0, 0,
  0, 0, 0, 0, 213, 0, 214, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 215, 0, 216,
  88, 0, 0, 0, 0, 0, 0, 217, 0, 0,
  218, 89, 0, 0, 0, 0, 219, 42, 43, 0,
  0, 0, 220, 0, 0, 0, 0, 85, 0, 0,
  0, 0, 0, 0, 86, 221, 0, 0, 87, 51,
  0, 52, 0, 42, 43, 0, 0, 0, 55, 0,
  0, 0, 58, 85, 0, 0, 0, 0, 0, 0,
  86, 0, 0, 0, 87, 51, 0, 52, 0, 0, 
  63, 0, 65, 0, 55, 0, 0, 0, 58, 0,
  0, 0, 0, 57, 68, 45, 0, 0, 0, 210,
  0, 0, 0, 0, 0, 0, 63, 0, 65, 211,
  0, 0, 0, 212, 0, 0, 0, 0, 0, 57,
  68, 45, 213, 0, 214, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 215, 0, 216, 88, 0,
  0, 0, 0, 0, 0, 217, 0, 0, 218, 89,
  0, 0, 0, 0, 219, 0, 0, 0, 0, 0,
  220, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 221, 0, 0, 0, 0, 0, 0,
  210, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  211, 0, 0, 0, 212, 0, 0, 0, 0, 0,
  0, 0, 0, 213, 0, 214, 0, 0, 307, 0,
  0, 0, 0, 0, 0, 0, 215, 0, 216, 88,
  0, 0, 0, 0, 0, 0, 217, 0, 0, 218,
  89, 0, 0, 0, 0, 219, 0, 0, 0, 0,
  0, 220, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 221, 0, 0, 0, 0, 0,
  0, 41, 42, 43, 0, 0, 0, 0, 0, 0, 
  0, 0, 85, 0, 0, 0, 0, 0, 0, 86, 
  0, 0, 0, 87, 51, 0, 52, 0, 0, 0, 
  53, 0, 54, 55, 56, 0, 0, 58, 0, 0, 
  0, 59, 0, 60, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 63, 0, 65, 0, 67, 
  0, 70, 0, 72, 0, 0, 0, 0, 57, 68,
  45, 0, 0, 0, 41, 42, 43, 0, 0, 0,
  0, 0, 0, 0, 0, 85, 0, 0, 0, 0,
  0, 0, 86, 0, 0, 0, 87, 51, 0, 52,
  0, 0, 0, 53, 0, 54, 55, 56, 0, 0,
  58, 0, 0, 0, 59, 0, 60, 0, 0, 443,
  0, 0, 0, 0, 0, 0, 0, 0, 63, 0,
  65, 0, 67, 0, 70, 0, 72, 0, 0, 0,
  0, 57, 68, 45, 0, 0, 0, -48, 0, 0,
  0, 41, 42, 43, 0, 0, 0, 0, 0, 0,
  0, 0, 85, 0, 0, 0, 0, 0, 0, 86,
  0, 0, 0, 87, 51, 0, 52, 0, 0, 0,
  53, 0, 54, 55, 56, 0, 0, 58, 0, 0, 
  0, 59, 0, 60, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 63, 0, 65, 0, 67,
  0, 70, 0, 72, 0, 0, 0, 0, 57, 68,
  45, 0, 0, 0, 41, 42, 43, 0, 0, 0,
  0, 0, 0, 0, 0, 85, 0, 0, 0, 0,
  0, 0, 86, 0, 0, 0, 87, 51, 0, 52,
  0, 0, 0, 53, 0, 54, 55, 56, 0, 0,
  58, 0, 0, 0, 59, 0, 60, 0, 0, 446,
  0, 0, 0, 0, 0, 0, 0, 0, 63, 0,
  65, 0, 67, 0, 70, 0, 72, 0, 0, 0,
  0, 57, 68, 45, 0, 0, 0, 41, 42, 43,
  0, 0, 0, 0, 0, 0, 0, 0, 85, 0,
  0, 0, 0, 0, 0, 86, 0, 0, 0, 87,
  51, 0, 52, 0, 0, 0, 53, 0, 54, 55,
  56, 0, 0, 58, 0, 0, 0, 59, 0, 60,
  0, 0, 0, 0, 0, 0, 203, 0, 0, 0,
  0, 63, 0, 65, 0, 67, 0, 70, 0, 72,
  0, 0, 0, 0, 57, 68, 45, 0, 0, 0,
  41, 42, 43, 0, 0, 0, 0, 0, 0, 0,
  0, 85, 0, 0, 0, 0, 0, 0, 86, 0,
  0, 0, 87, 51, 0, 52, 0, 0, 0, 53,
  0, 54, 55, 56, 0, 0, 58, 0, 0, 0,
  59, 0, 60, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 63, 0, 65, 0, 67, 0,
  70, 270, 72, 0, 0, 0, 0, 57, 68, 45,
  0, 0, 0, 115, 116, 117, 0, 0, 119, 121,
  122, 0, 0, 123, 0, 124, 0, 0, 0, 126,
  127, 128, 0, 0, 0, 0, 0, 0, 196, 130,
  131, 132, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 133, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 137, 0,
  0, 0, 0, 0, 0, 139, 140, 141, 0, 143,
  144, 145, 146, 147, 148, 0, 0, 134, 142, 125,
  118, 120, 136, 115, 116, 117, 0, 0, 119, 121,
  122, 0, 0, 123, 0, 124, 0, 0, 0, 126,
  127, 128, 0, 0, 0, 0, 0, 0, 129, 130,
  131, 132, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 133, 0, 0, 0, 135, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 137, 0,
  0, 0, 0, 0, 138, 139, 140, 141, 0, 143,
  144, 145, 146, 147, 148, 0, 0, 134, 142, 125,
  118, 120, 136, 115, 116, 117, 0, 0, 119, 121,
  122, 0, 0, 123, 0, 124, 0, 0, 0, 126,
  127, 128, 0, 0, 0, 0, 0, 0, 129, 130,
  131, 132, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 133, 0, 0, 0, 135, 0, 0, 0,
  0, 0, 0, 0, 153, 0, 0, 0, 137, 0,
  0, 0, 0, 0, 138, 139, 140, 141, 0, 143,
  144, 145, 146, 147, 148, 0, 0, 134, 142, 125,
  118, 120, 136, 37, 0, 0, 0, 0, 39, 0,
  41, 42, 43, 44, 0, 0, 0, 0, 0, 0,
  46, 85, 0, 0, 0, 0, 0, 0, 48, 49,
  0, 0, 50, 51, 0, 52, 0, 0, 0, 53,
  0, 54, 55, 56, 0, 0, 58, 0, 0, 0,
  59, 0, 60, 0, 0, 0, 0, 0, 61, 0,
  62, 0, 0, 0, 63, 64, 65, 66, 67, 69,
  70, 71, 72, 73, 74, 0, 0, 57, 68, 45,
  38, 40, 0, 37, 0, 0, 0, 0, 39, 0,
  41, 42, 43, 44, 0, 0, 0, 0, 0, 0,
  46, 47, 0, 0, 0, 0, 0, 0, 48, 49,
  0, 0, 50, 51, 0, 52, 0, 0, 0, 53,
  0, 54, 55, 56, 0, 0, 58, 0, 0, 0,
  59, 0, 60, 0, 0, 0, 0, 0, 61, 0,
  62, 0, 0, 0, 63, 64, 65, 66, 67, 69,
  70, 71, 72, 73, 74, 0, 0, 57, 68, 45,
  38, 40, 0, 356, 116, 117, 0, 0, 358, 121,
  360, 42, 43, 361, 0, 124, 0, 0, 0, 126,
  363, 364, 0, 0, 0, 0, 0, 0, 365, 366,
  131, 132, 50, 51, 0, 52, 0, 0, 0, 53,
  0, 54, 367, 56, 0, 0, 369, 0, 0, 0,
  59, 0, 60, 0, -191, 0, 0, 0, 370, 0,
  62, 0, 0, 0, 371, 372, 373, 374, 67, 376,
  377, 378, 379, 380, 381, 0, 0, 368, 375, 362,
  357, 359, 136,

  391, 423, 430, 442, 353, 428, 301, 399, 434, 465,
  441, 413, 410, 403, 445, 386, 407, 424, 461, 419,
  235, 306, 202, 197, 34, 155, 195, 200, 252, 249,
  206, 228, 230, 110, 150, 152, 209, 353, 110, 447,
  301, 410, 231, 413, 222, 328, 340, 337, 333, 335,
  343, 348, 308, 301, 249, 0, 83, 346, 382, 83,
  83, 0, 164, 0, 350, 285, 352, 159, 83, 83,
  83, 83, 83, 284, 310, 183, 179, 180, 83, 83,
  189, 0, 432, 178, 83, 185, 450, 83, 83, 331,
  0, 384, 171, 286, 385, 83, 83, 95, 453, 83,
  83, 451, 83, 353, 94, 287, 83, 83, 425, 93,
  83, 83, 83, 84, 426, 83, 181, 83, 157, 409,
  384, 83, 83, 385, 452, 195, 234, 83, 83, 248,
  265, 224, 301, 301, 184, 269, 353, 227, 83, 83,
  83, 248, 83, 83, 177, 301, 175, 83, 182, 83,
  187, 176, 406, 83, 283, 449, 83, 0, 425, 83,
  297, 426, 297, 0, 83, 269, 454, 269, 304, 302,
  83, 83, 83, 83, 297, 269, 269, 269, 269, 269,
  272, 329, 296, 294, 299, 312, 83, 83, 0, 0,
  315, 269, 269, 288, 277, 83, 316, 83, 297, 0,
  269, 297, 269, 269, 290, 0, 269, 0, 292, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  318, 0, 0, 325, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 83, 0, 0, 0, 0, 269,
  0, 289, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0};

const short QScriptGrammar::action_check [] = {
  7, 29, 76, 7, 16, 1, 36, 2, 61, 36,
  29, 8, 33, 7, 7, 7, 55, 48, 36, 60,
  33, 61, 5, 29, 61, 60, 29, 7, 36, 8,
  2, 7, 48, 1, 76, 5, 17, 60, 7, 5,
  7, 55, 33, 31, 55, 74, 36, 36, 7, 36,
  36, 29, 29, 55, 36, 7, 17, 8, 8, 8,
  33, 36, 60, 8, 29, 29, 7, 2, 2, 29,
  55, 33, 20, 36, 48, 76, 60, 7, 36, 33,
  7, 36, 29, 29, 8, 29, 0, 8, 8, 8,
  8, 48, 29, 36, 33, 8, 8, 8, 8, 36,
  40, 8, -1, 8, 8, 76, 42, 40, 61, 62,
  10, 51, 50, 6, 8, 40, 54, 53, 51, 61,
  62, 50, 8, 40, 12, 54, 51, 20, 12, 61,
  62, 7, 8, -1, 51, 56, -1, -1, 61, 62,
  60, 60, 60, 15, 25, 56, 27, 60, 8, 61,
  60, 56, 29, 60, 1, 55, 60, 38, 25, 29,
  27, 29, 34, 25, 36, 27, 60, 15, 25, 57,
  27, 38, 12, 57, 60, 63, 38, 15, 29, 63,
  8, 38, 8, -1, 61, 62, 34, -1, 36, -1,
  -1, 61, 62, 61, 62, -1, 34, -1, 36, 18,
  19, 61, 62, 18, 19, -1, -1, -1, -1, -1,
  61, 62, -1, 18, 19, 18, 19, 57, -1, -1,
  -1, -1, -1, 63, -1, -1, 45, 46, -1, -1,
  45, 46, -1, 61, 62, 61, 62, 25, -1, 27,
  45, 46, 45, 46, 23, 24, -1, -1, -1, -1,
  38, -1, 31, 32, 23, 24, 35, -1, 37, -1,
  -1, -1, 31, 32, 23, 24, 35, -1, 37, -1,
  -1, -1, 31, 32, 23, 24, 35, -1, 37, -1,
  -1, -1, 31, 32, -1, -1, 35, -1, 37, -1,
  23, 24, -1, -1, -1, -1, 23, 24, 31, 32,
  -1, 3, 35, -1, 37, 32, -1, -1, 35, -1,
  37, 13, -1, -1, -1, 17, -1, -1, -1, -1,
  -1, -1, -1, -1, 26, -1, 28, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, 39, -1, 41,
  42, -1, -1, -1, -1, -1, -1, 49, -1, -1,
  52, 53, -1, -1, -1, -1, 58, 12, 13, -1,
  -1, -1, 64, -1, -1, -1, -1, 22, -1, -1,
  -1, -1, -1, -1, 29, 77, -1, -1, 33, 34,
  -1, 36, -1, 12, 13, -1, -1, -1, 43, -1,
  -1, -1, 47, 22, -1, -1, -1, -1, -1, -1,
  29, -1, -1, -1, 33, 34, -1, 36, -1, -1, 
  65, -1, 67, -1, 43, -1, -1, -1, 47, -1,
  -1, -1, -1, 78, 79, 80, -1, -1, -1, 3,
  -1, -1, -1, -1, -1, -1, 65, -1, 67, 13,
  -1, -1, -1, 17, -1, -1, -1, -1, -1, 78,
  79, 80, 26, -1, 28, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, 39, -1, 41, 42, -1,
  -1, -1, -1, -1, -1, 49, -1, -1, 52, 53,
  -1, -1, -1, -1, 58, -1, -1, -1, -1, -1,
  64, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, 77, -1, -1, -1, -1, -1, -1,
  3, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  13, -1, -1, -1, 17, -1, -1, -1, -1, -1,
  -1, -1, -1, 26, -1, 28, -1, -1, 31, -1,
  -1, -1, -1, -1, -1, -1, 39, -1, 41, 42,
  -1, -1, -1, -1, -1, -1, 49, -1, -1, 52,
  53, -1, -1, -1, -1, 58, -1, -1, -1, -1,
  -1, 64, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, 77, -1, -1, -1, -1, -1,
  -1, 11, 12, 13, -1, -1, -1, -1, -1, -1, 
  -1, -1, 22, -1, -1, -1, -1, -1, -1, 29, 
  -1, -1, -1, 33, 34, -1, 36, -1, -1, -1, 
  40, -1, 42, 43, 44, -1, -1, 47, -1, -1, 
  -1, 51, -1, 53, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, 65, -1, 67, -1, 69, 
  -1, 71, -1, 73, -1, -1, -1, -1, 78, 79,
  80, -1, -1, -1, 11, 12, 13, -1, -1, -1,
  -1, -1, -1, -1, -1, 22, -1, -1, -1, -1,
  -1, -1, 29, -1, -1, -1, 33, 34, -1, 36,
  -1, -1, -1, 40, -1, 42, 43, 44, -1, -1,
  47, -1, -1, -1, 51, -1, 53, -1, -1, 56,
  -1, -1, -1, -1, -1, -1, -1, -1, 65, -1,
  67, -1, 69, -1, 71, -1, 73, -1, -1, -1,
  -1, 78, 79, 80, -1, -1, -1, 7, -1, -1,
  -1, 11, 12, 13, -1, -1, -1, -1, -1, -1,
  -1, -1, 22, -1, -1, -1, -1, -1, -1, 29,
  -1, -1, -1, 33, 34, -1, 36, -1, -1, -1,
  40, -1, 42, 43, 44, -1, -1, 47, -1, -1, 
  -1, 51, -1, 53, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, 65, -1, 67, -1, 69,
  -1, 71, -1, 73, -1, -1, -1, -1, 78, 79,
  80, -1, -1, -1, 11, 12, 13, -1, -1, -1,
  -1, -1, -1, -1, -1, 22, -1, -1, -1, -1,
  -1, -1, 29, -1, -1, -1, 33, 34, -1, 36,
  -1, -1, -1, 40, -1, 42, 43, 44, -1, -1,
  47, -1, -1, -1, 51, -1, 53, -1, -1, 56,
  -1, -1, -1, -1, -1, -1, -1, -1, 65, -1,
  67, -1, 69, -1, 71, -1, 73, -1, -1, -1,
  -1, 78, 79, 80, -1, -1, -1, 11, 12, 13,
  -1, -1, -1, -1, -1, -1, -1, -1, 22, -1,
  -1, -1, -1, -1, -1, 29, -1, -1, -1, 33,
  34, -1, 36, -1, -1, -1, 40, -1, 42, 43,
  44, -1, -1, 47, -1, -1, -1, 51, -1, 53,
  -1, -1, -1, -1, -1, -1, 60, -1, -1, -1,
  -1, 65, -1, 67, -1, 69, -1, 71, -1, 73,
  -1, -1, -1, -1, 78, 79, 80, -1, -1, -1,
  11, 12, 13, -1, -1, -1, -1, -1, -1, -1,
  -1, 22, -1, -1, -1, -1, -1, -1, 29, -1,
  -1, -1, 33, 34, -1, 36, -1, -1, -1, 40,
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1,
  51, -1, 53, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, 65, -1, 67, -1, 69, -1,
  71, 72, 73, -1, -1, -1, -1, 78, 79, 80,
  -1, -1, -1, 4, 5, 6, -1, -1, 9, 10,
  11, -1, -1, 14, -1, 16, -1, -1, -1, 20,
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30,
  31, 32, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, 43, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, 59, -1,
  -1, -1, -1, -1, -1, 66, 67, 68, -1, 70,
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80,
  81, 82, 83, 4, 5, 6, -1, -1, 9, 10,
  11, -1, -1, 14, -1, 16, -1, -1, -1, 20,
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30,
  31, 32, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, 43, -1, -1, -1, 47, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, 59, -1,
  -1, -1, -1, -1, 65, 66, 67, 68, -1, 70,
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80,
  81, 82, 83, 4, 5, 6, -1, -1, 9, 10,
  11, -1, -1, 14, -1, 16, -1, -1, -1, 20,
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30,
  31, 32, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, 43, -1, -1, -1, 47, -1, -1, -1,
  -1, -1, -1, -1, 55, -1, -1, -1, 59, -1,
  -1, -1, -1, -1, 65, 66, 67, 68, -1, 70,
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80,
  81, 82, 83, 4, -1, -1, -1, -1, 9, -1,
  11, 12, 13, 14, -1, -1, -1, -1, -1, -1,
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30,
  -1, -1, 33, 34, -1, 36, -1, -1, -1, 40,
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1,
  51, -1, 53, -1, -1, -1, -1, -1, 59, -1,
  61, -1, -1, -1, 65, 66, 67, 68, 69, 70,
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80,
  81, 82, -1, 4, -1, -1, -1, -1, 9, -1,
  11, 12, 13, 14, -1, -1, -1, -1, -1, -1,
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30,
  -1, -1, 33, 34, -1, 36, -1, -1, -1, 40,
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1,
  51, -1, 53, -1, -1, -1, -1, -1, 59, -1,
  61, -1, -1, -1, 65, 66, 67, 68, 69, 70,
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80,
  81, 82, -1, 4, 5, 6, -1, -1, 9, 10,
  11, 12, 13, 14, -1, 16, -1, -1, -1, 20,
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30,
  31, 32, 33, 34, -1, 36, -1, -1, -1, 40,
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1,
  51, -1, 53, -1, 55, -1, -1, -1, 59, -1,
  61, -1, -1, -1, 65, 66, 67, 68, 69, 70,
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80,
  81, 82, 83,

  6, 46, 45, 7, 45, 6, 6, 76, 45, 65,
  2, 46, 6, 73, 7, 14, 6, 46, 7, 78,
  6, 45, 7, 6, 85, 7, 10, 7, 6, 45,
  7, 7, 7, 86, 7, 9, 41, 45, 86, 6,
  6, 6, 14, 46, 7, 67, 80, 45, 45, 6,
  81, 6, 6, 6, 45, -1, 18, 45, 45, 18,
  18, -1, 24, -1, 45, 23, 45, 26, 18, 18,
  18, 18, 18, 23, 45, 24, 23, 23, 18, 18,
  28, -1, 6, 23, 18, 24, 20, 18, 18, 42,
  -1, 12, 23, 23, 15, 18, 18, 20, 20, 18,
  18, 20, 18, 45, 20, 23, 18, 18, 20, 20,
  18, 18, 18, 21, 20, 18, 23, 18, 21, 61,
  12, 18, 18, 15, 20, 10, 11, 18, 18, 20,
  18, 32, 6, 6, 24, 23, 45, 34, 18, 18,
  18, 20, 18, 18, 22, 6, 22, 18, 23, 18,
  30, 22, 61, 18, 23, 20, 18, -1, 20, 18,
  18, 20, 18, -1, 18, 23, 20, 23, 42, 42,
  18, 18, 18, 18, 18, 23, 23, 23, 23, 23,
  27, 42, 40, 29, 40, 33, 18, 18, -1, -1,
  35, 23, 23, 25, 25, 18, 40, 18, 18, -1,
  23, 18, 23, 23, 25, -1, 23, -1, 31, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  40, -1, -1, 40, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, 18, -1, -1, -1, -1, 23,
  -1, 25, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1};


#define Q_SCRIPT_REGEXPLITERAL_RULE1 7

#define Q_SCRIPT_REGEXPLITERAL_RULE2 8

#include <translator.h>

#include <QtCore/QCoreApplication>
#include <QtCore/qdebug.h>
#include <QtCore/qnumeric.h>
#include <QtCore/qstring.h>
#include <QtCore/qtextcodec.h>
#include <QtCore/qvariant.h>

#include <iostream>

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

QT_BEGIN_NAMESPACE

class LU {
    Q_DECLARE_TR_FUNCTIONS(LUpdate)
};

static QString MagicComment(QLatin1String("TRANSLATOR"));

static void recordMessage(
    Translator *tor, const QString &context, const QString &text, const QString &comment,
    const QString &extracomment, const QString &msgid, const TranslatorMessage::ExtraData &extra,
    bool plural, const QString &fileName, int lineNo)
{
    TranslatorMessage msg(
        context, text, comment, QString(),
        fileName, lineNo, QStringList(),
        TranslatorMessage::Unfinished, plural);
    msg.setExtraComment(extracomment.simplified());
    msg.setId(msgid);
    msg.setExtras(extra);
    tor->extend(msg);
}


namespace QScript
{

class CommentProcessor
{
public:
    virtual ~CommentProcessor() {}
    virtual void processComment(const QChar *chars, int length) = 0;
};

class Lexer
{
public:
    Lexer(CommentProcessor *);
    ~Lexer();

    void setCode(const QString &c, const QString &fileName, int lineno);
    int lex();

    QString fileName() const { return yyfilename; }
    int currentLineNo() const { return yylineno; }
    int currentColumnNo() const { return yycolumn; }

    int startLineNo() const { return startlineno; }
    int startColumnNo() const { return startcolumn; }

    int endLineNo() const { return currentLineNo(); }
    int endColumnNo() const
    { int col = currentColumnNo(); return (col > 0) ? col - 1 : col; }

    bool prevTerminator() const { return terminator; }

    enum State { Start,
                 Identifier,
                 InIdentifier,
                 InSingleLineComment,
                 InMultiLineComment,
                 InNum,
                 InNum0,
                 InHex,
                 InOctal,
                 InDecimal,
                 InExponentIndicator,
                 InExponent,
                 Hex,
                 Octal,
                 Number,
                 String,
                 Eof,
                 InString,
                 InEscapeSequence,
                 InHexEscape,
                 InUnicodeEscape,
                 Other,
                 Bad };

    enum Error {
        NoError,
        IllegalCharacter,
        UnclosedStringLiteral,
        IllegalEscapeSequence,
        IllegalUnicodeEscapeSequence,
        UnclosedComment,
        IllegalExponentIndicator,
        IllegalIdentifier
    };

    enum ParenthesesState {
        IgnoreParentheses,
        CountParentheses,
        BalancedParentheses
    };

    enum RegExpBodyPrefix {
        NoPrefix,
        EqualPrefix
    };

    bool scanRegExp(RegExpBodyPrefix prefix = NoPrefix);

    QString pattern;
    int flags;

    State lexerState() const
        { return state; }

    QString errorMessage() const
        { return errmsg; }
    void setErrorMessage(const QString &err)
        { errmsg = err; }
    void setErrorMessage(const char *err)
        { setErrorMessage(QString::fromLatin1(err)); }

    Error error() const
        { return err; }
    void clearError()
        { err = NoError; }

private:
    QString yyfilename;
    int yylineno;
    bool done;
    char *buffer8;
    QChar *buffer16;
    uint size8, size16;
    uint pos8, pos16;
    bool terminator;
    bool restrKeyword;
    // encountered delimiter like "'" and "}" on last run
    bool delimited;
    int stackToken;

    State state;
    void setDone(State s);
    uint pos;
    void shift(uint p);
    int lookupKeyword(const char *);

    bool isWhiteSpace() const;
    bool isLineTerminator() const;
    bool isHexDigit(ushort c) const;
    bool isOctalDigit(ushort c) const;

    int matchPunctuator(ushort c1, ushort c2,
                         ushort c3, ushort c4);
    ushort singleEscape(ushort c) const;
    ushort convertOctal(ushort c1, ushort c2,
                         ushort c3) const;
public:
    static unsigned char convertHex(ushort c1);
    static unsigned char convertHex(ushort c1, ushort c2);
    static QChar convertUnicode(ushort c1, ushort c2,
                                 ushort c3, ushort c4);
    static bool isIdentLetter(ushort c);
    static bool isDecimalDigit(ushort c);

    inline int ival() const { return qsyylval.toInt(); }
    inline double dval() const { return qsyylval.toDouble(); }
    inline QString ustr() const { return qsyylval.toString(); }
    inline QVariant val() const { return qsyylval; }

    const QChar *characterBuffer() const { return buffer16; }
    int characterCount() const { return pos16; }

private:
    void record8(ushort c);
    void record16(QChar c);
    void recordStartPos();

    int findReservedWord(const QChar *buffer, int size) const;

    void syncProhibitAutomaticSemicolon();

    void processComment(const QChar *, int);

    const QChar *code;
    uint length;
    int yycolumn;
    int startlineno;
    int startcolumn;
    int bol;     // begin of line

    QVariant qsyylval;

    // current and following unicode characters
    ushort current, next1, next2, next3;

    struct keyword {
        const char *name;
        int token;
    };

    QString errmsg;
    Error err;

    bool wantRx;
    bool check_reserved;

    ParenthesesState parenthesesState;
    int parenthesesCount;
    bool prohibitAutomaticSemicolon;

    CommentProcessor *commentProcessor;
};

} // namespace QScript

extern double qstrtod(const char *s00, char const **se, bool *ok);

#define shiftWindowsLineBreak() if(current == '\r' && next1 == '\n') shift(1);

namespace QScript {

static int toDigit(char c)
{
    if ((c >= '0') && (c <= '9'))
        return c - '0';
    else if ((c >= 'a') && (c <= 'z'))
        return 10 + c - 'a';
    else if ((c >= 'A') && (c <= 'Z'))
        return 10 + c - 'A';
    return -1;
}

double integerFromString(const char *buf, int size, int radix)
{
    if (size == 0)
        return qSNaN();

    double sign = 1.0;
    int i = 0;
    if (buf[0] == '+') {
        ++i;
    } else if (buf[0] == '-') {
        sign = -1.0;
        ++i;
    }

    if (((size-i) >= 2) && (buf[i] == '0')) {
        if (((buf[i+1] == 'x') || (buf[i+1] == 'X'))
            && (radix < 34)) {
            if ((radix != 0) && (radix != 16))
                return 0;
            radix = 16;
            i += 2;
        } else {
            if (radix == 0) {
                radix = 8;
                ++i;
            }
        }
    } else if (radix == 0) {
        radix = 10;
    }

    int j = i;
    for ( ; i < size; ++i) {
        int d = toDigit(buf[i]);
        if ((d == -1) || (d >= radix))
            break;
    }
    double result;
    if (j == i) {
        if (!qstrcmp(buf, "Infinity"))
            result = qInf();
        else
            result = qSNaN();
    } else {
        result = 0;
        double multiplier = 1;
        for (--i ; i >= j; --i, multiplier *= radix)
            result += toDigit(buf[i]) * multiplier;
    }
    result *= sign;
    return result;
}

} // namespace QScript

QScript::Lexer::Lexer(QScript::CommentProcessor *proc)
    :
      yylineno(0),
      size8(128), size16(128), restrKeyword(false),
      stackToken(-1), pos(0),
      code(0), length(0),
      bol(true),
      current(0), next1(0), next2(0), next3(0),
      err(NoError),
      check_reserved(true),
      parenthesesState(IgnoreParentheses),
      prohibitAutomaticSemicolon(false),
      commentProcessor(proc)
{
    // allocate space for read buffers
    buffer8 = new char[size8];
    buffer16 = new QChar[size16];
    flags = 0;

}

QScript::Lexer::~Lexer()
{
    delete [] buffer8;
    delete [] buffer16;
}

void QScript::Lexer::setCode(const QString &c, const QString &fileName, int lineno)
{
    errmsg = QString();
    yyfilename = fileName;
    yylineno = lineno;
    yycolumn = 1;
    restrKeyword = false;
    delimited = false;
    stackToken = -1;
    pos = 0;
    code = c.unicode();
    length = c.length();
    bol = true;

    // read first characters
    current = (length > 0) ? code[0].unicode() : 0;
    next1 = (length > 1) ? code[1].unicode() : 0;
    next2 = (length > 2) ? code[2].unicode() : 0;
    next3 = (length > 3) ? code[3].unicode() : 0;
}

void QScript::Lexer::shift(uint p)
{
    while (p--) {
        ++pos;
        ++yycolumn;
        current = next1;
        next1 = next2;
        next2 = next3;
        next3 = (pos + 3 < length) ? code[pos+3].unicode() : 0;
    }
}

void QScript::Lexer::setDone(State s)
{
    state = s;
    done = true;
}

int QScript::Lexer::findReservedWord(const QChar *c, int size) const
{
    switch (size) {
    case 2: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o'))
            return QScriptGrammar::T_DO;
        else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('f'))
            return QScriptGrammar::T_IF;
        else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n'))
            return QScriptGrammar::T_IN;
    }   break;

    case 3: {
        if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('o') && c[2] == QLatin1Char('r'))
            return QScriptGrammar::T_FOR;
        else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('e') && c[2] == QLatin1Char('w'))
            return QScriptGrammar::T_NEW;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r') && c[2] == QLatin1Char('y'))
            return QScriptGrammar::T_TRY;
        else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('a') && c[2] == QLatin1Char('r'))
            return QScriptGrammar::T_VAR;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n') && c[2] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 4: {
        if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_CASE;
        else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('l')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_ELSE;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('s'))
            return QScriptGrammar::T_THIS;
        else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('d'))
            return QScriptGrammar::T_VOID;
        else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('i')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('h'))
            return QScriptGrammar::T_WITH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_TRUE;
        else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('u')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('l'))
            return QScriptGrammar::T_NULL;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('n')
                    && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('m'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('y')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('l') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('g'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('r'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('g') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('o'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 5: {
        if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('r')
                && c[2] == QLatin1Char('e') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('k'))
            return QScriptGrammar::T_BREAK;
        else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('c')
                && c[4] == QLatin1Char('h'))
            return QScriptGrammar::T_CATCH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                && c[4] == QLatin1Char('w'))
            return QScriptGrammar::T_THROW;
        else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('l')
                && c[4] == QLatin1Char('e'))
            return QScriptGrammar::T_WHILE;
        else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('s')
                && c[4] == QLatin1Char('t'))
            return QScriptGrammar::T_CONST;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('s')
                && c[4] == QLatin1Char('e'))
            return QScriptGrammar::T_FALSE;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('r')
                    && c[4] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('r'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('l'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('l')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('s')
                    && c[4] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('l')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 6: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('e')
                && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('e'))
            return QScriptGrammar::T_DELETE;
        else if (c[0] == QLatin1Char('r') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('u')
                && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('n'))
            return QScriptGrammar::T_RETURN;
        else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('w')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('c') && c[5] == QLatin1Char('h'))
            return QScriptGrammar::T_SWITCH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('y')
                && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                && c[4] == QLatin1Char('o') && c[5] == QLatin1Char('f'))
            return QScriptGrammar::T_TYPEOF;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('t')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('b')
                    && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('i')
                    && c[4] == QLatin1Char('v') && c[5] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('w') && c[5] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 7: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('f') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('u') && c[5] == QLatin1Char('l')
                && c[6] == QLatin1Char('t'))
            return QScriptGrammar::T_DEFAULT;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('l')
                && c[6] == QLatin1Char('y'))
            return QScriptGrammar::T_FINALLY;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('a')
                    && c[6] == QLatin1Char('n'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('n') && c[5] == QLatin1Char('d')
                    && c[6] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('c') && c[3] == QLatin1Char('k')
                    && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('g')
                    && c[6] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('v')
                    && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('t')
                    && c[6] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 8: {
        if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('n')
                && c[6] == QLatin1Char('u') && c[7] == QLatin1Char('e'))
            return QScriptGrammar::T_CONTINUE;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('u')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n'))
            return QScriptGrammar::T_FUNCTION;
        else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('u')
                && c[4] == QLatin1Char('g') && c[5] == QLatin1Char('g')
                && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('r'))
            return QScriptGrammar::T_DEBUGGER;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('a') && c[1] == QLatin1Char('b')
                    && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('a')
                    && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                    && c[6] == QLatin1Char('l') && c[7] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 9: {
        if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('f')
                    && c[6] == QLatin1Char('a') && c[7] == QLatin1Char('c')
                    && c[8] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('n')
                    && c[4] == QLatin1Char('s') && c[5] == QLatin1Char('i')
                    && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('c')
                    && c[6] == QLatin1Char('t') && c[7] == QLatin1Char('e')
                    && c[8] == QLatin1Char('d'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 10: {
        if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('n')
                && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('e')
                && c[8] == QLatin1Char('o') && c[9] == QLatin1Char('f'))
            return QScriptGrammar::T_INSTANCEOF;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('m')
                    && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('t') && c[9] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 12: {
        if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('y')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                    && c[4] == QLatin1Char('h') && c[5] == QLatin1Char('r')
                    && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('i') && c[9] == QLatin1Char('z')
                    && c[10] == QLatin1Char('e') && c[11] == QLatin1Char('d'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    } // switch

    return -1;
}

int QScript::Lexer::lex()
{
    int token = 0;
    state = Start;
    ushort stringType = 0; // either single or double quotes
    pos8 = pos16 = 0;
    done = false;
    terminator = false;

    // did we push a token on the stack previously ?
    // (after an automatic semicolon insertion)
    if (stackToken >= 0) {
        setDone(Other);
        token = stackToken;
        stackToken = -1;
    }

    while (!done) {
        switch (state) {
        case Start:
            if (isWhiteSpace()) {
                // do nothing
            } else if (current == '/' && next1 == '/') {
                recordStartPos();
                shift(1);
                Q_ASSERT(pos16 == 0);
                state = InSingleLineComment;
            } else if (current == '/' && next1 == '*') {
                recordStartPos();
                shift(1);
                Q_ASSERT(pos16 == 0);
                state = InMultiLineComment;
            } else if (current == 0) {
                syncProhibitAutomaticSemicolon();
                if (!terminator && !delimited && !prohibitAutomaticSemicolon) {
                    // automatic semicolon insertion if program incomplete
                    token = QScriptGrammar::T_SEMICOLON;
                    stackToken = 0;
                    setDone(Other);
                } else {
                    setDone(Eof);
                }
            } else if (isLineTerminator()) {
                shiftWindowsLineBreak();
                yylineno++;
                yycolumn = 0;
                bol = true;
                terminator = true;
                syncProhibitAutomaticSemicolon();
                if (restrKeyword) {
                    token = QScriptGrammar::T_SEMICOLON;
                    setDone(Other);
                }
            } else if (current == '"' || current == '\'') {
                recordStartPos();
                state = InString;
                stringType = current;
            } else if (isIdentLetter(current)) {
                recordStartPos();
                record16(current);
                state = InIdentifier;
            } else if (current == '0') {
                recordStartPos();
                record8(current);
                state = InNum0;
            } else if (isDecimalDigit(current)) {
                recordStartPos();
                record8(current);
                state = InNum;
            } else if (current == '.' && isDecimalDigit(next1)) {
                recordStartPos();
                record8(current);
                state = InDecimal;
            } else {
                recordStartPos();
                token = matchPunctuator(current, next1, next2, next3);
                if (token != -1) {
                    if (terminator && !delimited && !prohibitAutomaticSemicolon
                        && (token == QScriptGrammar::T_PLUS_PLUS
                            || token == QScriptGrammar::T_MINUS_MINUS)) {
                        // automatic semicolon insertion
                        stackToken = token;
                        token = QScriptGrammar::T_SEMICOLON;
                    }
                    setDone(Other);
                }
                else {
                    setDone(Bad);
                    err = IllegalCharacter;
                    errmsg = LU::tr("Illegal character");
                }
            }
            break;
        case InString:
            if (current == stringType) {
                shift(1);
                setDone(String);
            } else if (current == 0 || isLineTerminator()) {
                setDone(Bad);
                err = UnclosedStringLiteral;
                errmsg = LU::tr("Unclosed string at end of line");
            } else if (current == '\\') {
                state = InEscapeSequence;
            } else {
                record16(current);
            }
            break;
            // Escape Sequences inside of strings
        case InEscapeSequence:
            if (isOctalDigit(current)) {
                if (current >= '0' && current <= '3' &&
                     isOctalDigit(next1) && isOctalDigit(next2)) {
                    record16(convertOctal(current, next1, next2));
                    shift(2);
                    state = InString;
                } else if (isOctalDigit(current) &&
                            isOctalDigit(next1)) {
                    record16(convertOctal('0', current, next1));
                    shift(1);
                    state = InString;
                } else if (isOctalDigit(current)) {
                    record16(convertOctal('0', '0', current));
                    state = InString;
                } else {
                    setDone(Bad);
                    err = IllegalEscapeSequence;
                    errmsg = LU::tr("Illegal escape sequence");
                }
            } else if (current == 'x')
                state = InHexEscape;
            else if (current == 'u')
                state = InUnicodeEscape;
            else {
                record16(singleEscape(current));
                state = InString;
            }
            break;
        case InHexEscape:
            if (isHexDigit(current) && isHexDigit(next1)) {
                state = InString;
                record16(QLatin1Char(convertHex(current, next1)));
                shift(1);
            } else if (current == stringType) {
                record16(QLatin1Char('x'));
                shift(1);
                setDone(String);
            } else {
                record16(QLatin1Char('x'));
                record16(current);
                state = InString;
            }
            break;
        case InUnicodeEscape:
            if (isHexDigit(current) && isHexDigit(next1) &&
                 isHexDigit(next2) && isHexDigit(next3)) {
                record16(convertUnicode(current, next1, next2, next3));
                shift(3);
                state = InString;
            } else if (current == stringType) {
                record16(QLatin1Char('u'));
                shift(1);
                setDone(String);
            } else {
                setDone(Bad);
                err = IllegalUnicodeEscapeSequence;
                errmsg = LU::tr("Illegal unicode escape sequence");
            }
            break;
        case InSingleLineComment:
            if (isLineTerminator()) {
                record16(current); // include newline
                processComment(buffer16, pos16);
                shiftWindowsLineBreak();
                yylineno++;
                yycolumn = 0;
                pos16 = 0;
                terminator = true;
                bol = true;
                if (restrKeyword) {
                    token = QScriptGrammar::T_SEMICOLON;
                    setDone(Other);
                } else
                    state = Start;
            } else if (current == 0) {
                setDone(Eof);
            } else {
                record16(current);
            }
            break;
        case InMultiLineComment:
            if (current == 0) {
                setDone(Bad);
                err = UnclosedComment;
                errmsg = LU::tr("Unclosed comment at end of file");
            } else if (isLineTerminator()) {
                shiftWindowsLineBreak();
                yylineno++;
            } else if (current == '*' && next1 == '/') {
                processComment(buffer16, pos16);
                pos16 = 0;
                state = Start;
                shift(1);
            } else {
                record16(current);
            }
            break;
        case InIdentifier:
            if (isIdentLetter(current) || isDecimalDigit(current)) {
                record16(current);
                break;
            }
            setDone(Identifier);
            break;
        case InNum0:
            if (current == 'x' || current == 'X') {
                record8(current);
                state = InHex;
            } else if (current == '.') {
                record8(current);
                state = InDecimal;
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else if (isOctalDigit(current)) {
                record8(current);
                state = InOctal;
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InDecimal;
            } else {
                setDone(Number);
            }
            break;
        case InHex:
            if (isHexDigit(current))
                record8(current);
            else
                setDone(Hex);
            break;
        case InOctal:
            if (isOctalDigit(current)) {
                record8(current);
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InDecimal;
            } else {
                setDone(Octal);
            }
            break;
        case InNum:
            if (isDecimalDigit(current)) {
                record8(current);
            } else if (current == '.') {
                record8(current);
                state = InDecimal;
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else {
                setDone(Number);
            }
            break;
        case InDecimal:
            if (isDecimalDigit(current)) {
                record8(current);
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else {
                setDone(Number);
            }
            break;
        case InExponentIndicator:
            if (current == '+' || current == '-') {
                record8(current);
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InExponent;
            } else {
                setDone(Bad);
                err = IllegalExponentIndicator;
                errmsg = LU::tr("Illegal syntax for exponential number");
            }
            break;
        case InExponent:
            if (isDecimalDigit(current)) {
                record8(current);
            } else {
                setDone(Number);
            }
            break;
        default:
            Q_ASSERT_X(0, "Lexer::lex", "Unhandled state in switch statement");
        }

        // move on to the next character
        if (!done)
            shift(1);
        if (state != Start && state != InSingleLineComment)
            bol = false;
    }

    // no identifiers allowed directly after numeric literal, e.g. "3in" is bad
    if ((state == Number || state == Octal || state == Hex)
         && isIdentLetter(current)) {
        state = Bad;
        err = IllegalIdentifier;
        errmsg = LU::tr("Identifier cannot start with numeric literal");
    }

    // terminate string
    buffer8[pos8] = '\0';

    double dval = 0;
    if (state == Number) {
        dval = qstrtod(buffer8, 0, 0);
    } else if (state == Hex) { // scan hex numbers
        dval = QScript::integerFromString(buffer8, pos8, 16);
        state = Number;
    } else if (state == Octal) {   // scan octal number
        dval = QScript::integerFromString(buffer8, pos8, 8);
        state = Number;
    }

    restrKeyword = false;
    delimited = false;

    switch (parenthesesState) {
    case IgnoreParentheses:
        break;
    case CountParentheses:
        if (token == QScriptGrammar::T_RPAREN) {
            --parenthesesCount;
            if (parenthesesCount == 0)
                parenthesesState = BalancedParentheses;
        } else if (token == QScriptGrammar::T_LPAREN) {
            ++parenthesesCount;
        }
        break;
    case BalancedParentheses:
        parenthesesState = IgnoreParentheses;
        break;
    }

    switch (state) {
    case Eof:
        return 0;
    case Other:
        if(token == QScriptGrammar::T_RBRACE || token == QScriptGrammar::T_SEMICOLON)
            delimited = true;
        return token;
    case Identifier:
        if ((token = findReservedWord(buffer16, pos16)) < 0) {
            /* TODO: close leak on parse error. same holds true for String */
            qsyylval = QString(buffer16, pos16);
            return QScriptGrammar::T_IDENTIFIER;
        }
        if (token == QScriptGrammar::T_CONTINUE || token == QScriptGrammar::T_BREAK
            || token == QScriptGrammar::T_RETURN || token == QScriptGrammar::T_THROW) {
            restrKeyword = true;
        } else if (token == QScriptGrammar::T_IF || token == QScriptGrammar::T_FOR
                   || token == QScriptGrammar::T_WHILE || token == QScriptGrammar::T_WITH) {
            parenthesesState = CountParentheses;
            parenthesesCount = 0;
        } else if (token == QScriptGrammar::T_DO) {
            parenthesesState = BalancedParentheses;
        }
        return token;
    case String:
        qsyylval = QString(buffer16, pos16);
        return QScriptGrammar::T_STRING_LITERAL;
    case Number:
        qsyylval = dval;
        return QScriptGrammar::T_NUMERIC_LITERAL;
    case Bad:
        return -1;
    default:
        Q_ASSERT(!"unhandled numeration value in switch");
        return -1;
    }
}

bool QScript::Lexer::isWhiteSpace() const
{
    return (current == ' ' || current == '\t' ||
             current == 0x0b || current == 0x0c);
}

bool QScript::Lexer::isLineTerminator() const
{
    return (current == '\n' || current == '\r');
}

bool QScript::Lexer::isIdentLetter(ushort c)
{
    /* TODO: allow other legitimate unicode chars */
    return ((c >= 'a' && c <= 'z')
            || (c >= 'A' && c <= 'Z')
            || c == '$'
            || c == '_');
}

bool QScript::Lexer::isDecimalDigit(ushort c)
{
    return (c >= '0' && c <= '9');
}

bool QScript::Lexer::isHexDigit(ushort c) const
{
    return ((c >= '0' && c <= '9')
            || (c >= 'a' && c <= 'f')
            || (c >= 'A' && c <= 'F'));
}

bool QScript::Lexer::isOctalDigit(ushort c) const
{
    return (c >= '0' && c <= '7');
}

int QScript::Lexer::matchPunctuator(ushort c1, ushort c2,
                            ushort c3, ushort c4)
{
    if (c1 == '>' && c2 == '>' && c3 == '>' && c4 == '=') {
        shift(4);
        return QScriptGrammar::T_GT_GT_GT_EQ;
    } else if (c1 == '=' && c2 == '=' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_EQ_EQ_EQ;
    } else if (c1 == '!' && c2 == '=' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_NOT_EQ_EQ;
    } else if (c1 == '>' && c2 == '>' && c3 == '>') {
        shift(3);
        return QScriptGrammar::T_GT_GT_GT;
    } else if (c1 == '<' && c2 == '<' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_LT_LT_EQ;
    } else if (c1 == '>' && c2 == '>' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_GT_GT_EQ;
    } else if (c1 == '<' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_LE;
    } else if (c1 == '>' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_GE;
    } else if (c1 == '!' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_NOT_EQ;
    } else if (c1 == '+' && c2 == '+') {
        shift(2);
        return QScriptGrammar::T_PLUS_PLUS;
    } else if (c1 == '-' && c2 == '-') {
        shift(2);
        return QScriptGrammar::T_MINUS_MINUS;
    } else if (c1 == '=' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_EQ_EQ;
    } else if (c1 == '+' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_PLUS_EQ;
    } else if (c1 == '-' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_MINUS_EQ;
    } else if (c1 == '*' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_STAR_EQ;
    } else if (c1 == '/' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_DIVIDE_EQ;
    } else if (c1 == '&' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_AND_EQ;
    } else if (c1 == '^' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_XOR_EQ;
    } else if (c1 == '%' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_REMAINDER_EQ;
    } else if (c1 == '|' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_OR_EQ;
    } else if (c1 == '<' && c2 == '<') {
        shift(2);
        return QScriptGrammar::T_LT_LT;
    } else if (c1 == '>' && c2 == '>') {
        shift(2);
        return QScriptGrammar::T_GT_GT;
    } else if (c1 == '&' && c2 == '&') {
        shift(2);
        return QScriptGrammar::T_AND_AND;
    } else if (c1 == '|' && c2 == '|') {
        shift(2);
        return QScriptGrammar::T_OR_OR;
    }

    switch(c1) {
        case '=': shift(1); return QScriptGrammar::T_EQ;
        case '>': shift(1); return QScriptGrammar::T_GT;
        case '<': shift(1); return QScriptGrammar::T_LT;
        case ',': shift(1); return QScriptGrammar::T_COMMA;
        case '!': shift(1); return QScriptGrammar::T_NOT;
        case '~': shift(1); return QScriptGrammar::T_TILDE;
        case '?': shift(1); return QScriptGrammar::T_QUESTION;
        case ':': shift(1); return QScriptGrammar::T_COLON;
        case '.': shift(1); return QScriptGrammar::T_DOT;
        case '+': shift(1); return QScriptGrammar::T_PLUS;
        case '-': shift(1); return QScriptGrammar::T_MINUS;
        case '*': shift(1); return QScriptGrammar::T_STAR;
        case '/': shift(1); return QScriptGrammar::T_DIVIDE_;
        case '&': shift(1); return QScriptGrammar::T_AND;
        case '|': shift(1); return QScriptGrammar::T_OR;
        case '^': shift(1); return QScriptGrammar::T_XOR;
        case '%': shift(1); return QScriptGrammar::T_REMAINDER;
        case '(': shift(1); return QScriptGrammar::T_LPAREN;
        case ')': shift(1); return QScriptGrammar::T_RPAREN;
        case '{': shift(1); return QScriptGrammar::T_LBRACE;
        case '}': shift(1); return QScriptGrammar::T_RBRACE;
        case '[': shift(1); return QScriptGrammar::T_LBRACKET;
        case ']': shift(1); return QScriptGrammar::T_RBRACKET;
        case ';': shift(1); return QScriptGrammar::T_SEMICOLON;

        default: return -1;
    }
}

ushort QScript::Lexer::singleEscape(ushort c) const
{
    switch(c) {
    case 'b':
        return 0x08;
    case 't':
        return 0x09;
    case 'n':
        return 0x0A;
    case 'v':
        return 0x0B;
    case 'f':
        return 0x0C;
    case 'r':
        return 0x0D;
    case '"':
        return 0x22;
    case '\'':
        return 0x27;
    case '\\':
        return 0x5C;
    default:
        return c;
    }
}

ushort QScript::Lexer::convertOctal(ushort c1, ushort c2,
                            ushort c3) const
{
    return ((c1 - '0') * 64 + (c2 - '0') * 8 + c3 - '0');
}

unsigned char QScript::Lexer::convertHex(ushort c)
{
    if (c >= '0' && c <= '9')
        return (c - '0');
    else if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);
    else
        return (c - 'A' + 10);
}

unsigned char QScript::Lexer::convertHex(ushort c1, ushort c2)
{
    return ((convertHex(c1) << 4) + convertHex(c2));
}

QChar QScript::Lexer::convertUnicode(ushort c1, ushort c2,
                             ushort c3, ushort c4)
{
    return QChar((convertHex(c3) << 4) + convertHex(c4),
                  (convertHex(c1) << 4) + convertHex(c2));
}

void QScript::Lexer::record8(ushort c)
{
    Q_ASSERT(c <= 0xff);

    // enlarge buffer if full
    if (pos8 >= size8 - 1) {
        char *tmp = new char[2 * size8];
        memcpy(tmp, buffer8, size8 * sizeof(char));
        delete [] buffer8;
        buffer8 = tmp;
        size8 *= 2;
    }

    buffer8[pos8++] = (char) c;
}

void QScript::Lexer::record16(QChar c)
{
    // enlarge buffer if full
    if (pos16 >= size16 - 1) {
        QChar *tmp = new QChar[2 * size16];
        memcpy(tmp, buffer16, size16 * sizeof(QChar));
        delete [] buffer16;
        buffer16 = tmp;
        size16 *= 2;
    }

    buffer16[pos16++] = c;
}

void QScript::Lexer::recordStartPos()
{
    startlineno = yylineno;
    startcolumn = yycolumn;
}

bool QScript::Lexer::scanRegExp(RegExpBodyPrefix prefix)
{
    pos16 = 0;
    bool lastWasEscape = false;

    if (prefix == EqualPrefix)
        record16(QLatin1Char('='));

    while (1) {
        if (isLineTerminator() || current == 0) {
            errmsg = LU::tr("Unterminated regular expression literal");
            return false;
        }
        else if (current != '/' || lastWasEscape == true)
            {
                record16(current);
                lastWasEscape = !lastWasEscape && (current == '\\');
            }
        else {
            pattern = QString(buffer16, pos16);
            pos16 = 0;
            shift(1);
            break;
        }
        shift(1);
    }

    flags = 0;
    while (isIdentLetter(current)) {
        record16(current);
        shift(1);
    }

    return true;
}

void QScript::Lexer::syncProhibitAutomaticSemicolon()
{
    if (parenthesesState == BalancedParentheses) {
        // we have seen something like "if (foo)", which means we should
        // never insert an automatic semicolon at this point, since it would
        // then be expanded into an empty statement (ECMA-262 7.9.1)
        prohibitAutomaticSemicolon = true;
        parenthesesState = IgnoreParentheses;
    } else {
        prohibitAutomaticSemicolon = false;
    }
}

void QScript::Lexer::processComment(const QChar *chars, int length)
{
    commentProcessor->processComment(chars, length);
}


class Translator;

class QScriptParser: protected QScriptGrammar, public QScript::CommentProcessor
{
public:
    QVariant val;

    struct Location {
      int startLine;
      int startColumn;
      int endLine;
      int endColumn;
    };

public:
    QScriptParser();
    ~QScriptParser();

    void setLexer(QScript::Lexer *);
    void setTranslator(Translator *);

    bool parse();

    QString fileName() const
    { return lexer->fileName(); }
    inline QString errorMessage() const
    { return error_message; }
    inline int errorLineNumber() const
    { return error_lineno; }
    inline int errorColumnNumber() const
    { return error_column; }

protected:
    inline void reallocateStack();

    inline QVariant &sym(int index)
    { return sym_stack [tos + index - 1]; }

    inline Location &loc(int index)
    { return location_stack [tos + index - 2]; }

    std::ostream &yyMsg(int line = 0);

    virtual void processComment(const QChar *, int);

protected:
    int tos;
    int stack_size;
    QVector<QVariant> sym_stack;
    int *state_stack;
    Location *location_stack;
    QString error_message;
    int error_lineno;
    int error_column;

private:
    QScript::Lexer *lexer;
    Translator *translator;
    QString trcontext;
    QString extracomment;
    QString msgid;
    QString sourcetext;
    TranslatorMessage::ExtraData extra;
};

inline void QScriptParser::reallocateStack()
{
    if (! stack_size)
        stack_size = 128;
    else
        stack_size <<= 1;

    sym_stack.resize(stack_size);
    state_stack = reinterpret_cast<int*> (qRealloc(state_stack, stack_size * sizeof(int)));
    location_stack = reinterpret_cast<Location*> (qRealloc(location_stack, stack_size * sizeof(Location)));
}

inline static bool automatic(QScript::Lexer *lexer, int token)
{
    return (token == QScriptGrammar::T_RBRACE)
        || (token == 0)
        || lexer->prevTerminator();
}

QScriptParser::QScriptParser():
    tos(0),
    stack_size(0),
    sym_stack(0),
    state_stack(0),
    location_stack(0),
    lexer(0),
    translator(0)
{
}

QScriptParser::~QScriptParser()
{
    if (stack_size) {
        qFree(state_stack);
        qFree(location_stack);
    }
}

static inline QScriptParser::Location location(QScript::Lexer *lexer)
{
    QScriptParser::Location loc;
    loc.startLine = lexer->startLineNo();
    loc.startColumn = lexer->startColumnNo();
    loc.endLine = lexer->endLineNo();
    loc.endColumn = lexer->endColumnNo();
    return loc;
}

void QScriptParser::setLexer(QScript::Lexer *lex)
{
    lexer = lex;
}

void QScriptParser::setTranslator(Translator *tor)
{
    translator = tor;
}

bool QScriptParser::parse()
{
  Q_ASSERT(lexer != 0);
  Q_ASSERT(translator != 0);
  trcontext = QFileInfo(fileName()).baseName();

  const int INITIAL_STATE = 0;

  int yytoken = -1;
  int saved_yytoken = -1;
  int identLineNo = -1;

  reallocateStack();

  tos = 0;
  state_stack[++tos] = INITIAL_STATE;

  while (true)
    {
      const int state = state_stack [tos];
      if (yytoken == -1 && - TERMINAL_COUNT != action_index [state])
        {
          if (saved_yytoken == -1)
            {
              yytoken = lexer->lex();
              location_stack [tos] = location(lexer);
            }
          else
            {
              yytoken = saved_yytoken;
              saved_yytoken = -1;
            }
        }

      int act = t_action (state, yytoken);

      if (act == ACCEPT_STATE)
        return true;

      else if (act > 0)
        {
          if (++tos == stack_size)
            reallocateStack();

          sym_stack [tos] = lexer->val ();
          state_stack [tos] = act;
          location_stack [tos] = location(lexer);
          yytoken = -1;
        }

      else if (act < 0)
        {
          int r = - act - 1;

          tos -= rhs [r];
          act = state_stack [tos++];

          switch (r) {

case 1: {
    sym(1) = sym(1).toByteArray();
    identLineNo = lexer->startLineNo();
} break;

case 7: {
  bool rx = lexer->scanRegExp(QScript::Lexer::NoPrefix);
  if (!rx) {
      error_message = lexer->errorMessage();
      error_lineno = lexer->startLineNo();
      error_column = lexer->startColumnNo();
      return false;
  }
} break;

case 8: {
  bool rx = lexer->scanRegExp(QScript::Lexer::EqualPrefix);
  if (!rx) {
      error_message = lexer->errorMessage();
      error_lineno = lexer->startLineNo();
      error_column = lexer->startColumnNo();
      return false;
  }
} break;

case 67: {
    QString name = sym(1).toString();
    if ((name == QLatin1String("qsTranslate")) || (name == QLatin1String("QT_TRANSLATE_NOOP"))) {
        if (!sourcetext.isEmpty())
            yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").arg(name));
        QVariantList args = sym(2).toList();
        if (args.size() < 2) {
            yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least two arguments.\n").arg(name));
        } else {
            if ((args.at(0).type() != QVariant::String)
                || (args.at(1).type() != QVariant::String)) {
                yyMsg(identLineNo) << qPrintable(LU::tr("%1(): both arguments must be literal strings.\n").arg(name));
            } else {
                QString context = args.at(0).toString();
                QString text = args.at(1).toString();
                QString comment = args.value(2).toString();
                bool plural = (args.size() > 4);
                recordMessage(translator, context, text, comment, extracomment,
                              msgid, extra, plural, fileName(), identLineNo);
            }
        }
        sourcetext.clear();
        extracomment.clear();
        msgid.clear();
        extra.clear();
    } else if ((name == QLatin1String("qsTr")) || (name == QLatin1String("QT_TR_NOOP"))) {
        if (!sourcetext.isEmpty())
            yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").arg(name));
        QVariantList args = sym(2).toList();
        if (args.size() < 1) {
            yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least one argument.\n").arg(name));
        } else {
            if (args.at(0).type() != QVariant::String) {
                yyMsg(identLineNo) << qPrintable(LU::tr("%1(): text to translate must be a literal string.\n").arg(name));
            } else {
                QString text = args.at(0).toString();
                QString comment = args.value(1).toString();
                bool plural = (args.size() > 2);
                recordMessage(translator, trcontext, text, comment, extracomment,
                              msgid, extra, plural, fileName(), identLineNo);
            }
        }
        sourcetext.clear();
        extracomment.clear();
        msgid.clear();
        extra.clear();
    } else if ((name == QLatin1String("qsTrId")) || (name == QLatin1String("QT_TRID_NOOP"))) {
        if (!msgid.isEmpty())
            yyMsg(identLineNo) << qPrintable(LU::tr("//= cannot be used with %1(). Ignoring\n").arg(name));
        QVariantList args = sym(2).toList();
        if (args.size() < 1) {
            yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least one argument.\n").arg(name));
        } else {
            if (args.at(0).type() != QVariant::String) {
                yyMsg(identLineNo) << qPrintable(LU::tr("%1(): identifier must be a literal string.\n").arg(name));
            } else {
                msgid = args.at(0).toString();
                bool plural = (args.size() > 1);
                recordMessage(translator, QString(), sourcetext, QString(), extracomment,
                              msgid, extra, plural, fileName(), identLineNo);
            }
        }
        sourcetext.clear();
        extracomment.clear();
        msgid.clear();
        extra.clear();
    }
} break;

case 71: {
    sym(1) = QVariantList();
} break;

case 72: {
    sym(1) = sym(2);
} break;

case 73: {
    sym(1) = QVariantList() << sym(1);
} break;

case 74: {
    sym(1) = sym(1).toList() << sym(3);
} break;

case 95: {
    if ((sym(1).type() == QVariant::String) || (sym(3).type() == QVariant::String))
        sym(1) = sym(1).toString() + sym(3).toString();
    else
        sym(1) = QVariant();
} break;

    case 172:

    case 173:

    case 174:

    case 175:

    case 176:

    case 177:

    case 178:

    case 179:

    case 180:

    case 181:

    case 182:

    case 183:

    case 184:

    case 185:

    case 186:
    if (!sourcetext.isEmpty() || !extracomment.isEmpty() || !msgid.isEmpty() || !extra.isEmpty()) {
        yyMsg() << qPrintable(LU::tr("Discarding unconsumed meta data\n"));
        sourcetext.clear();
        extracomment.clear();
        msgid.clear();
        extra.clear();
    }
    break;

          } // switch

          state_stack [tos] = nt_action (act, lhs [r] - TERMINAL_COUNT);

          if (rhs[r] > 1) {
              location_stack[tos - 1].endLine = location_stack[tos + rhs[r] - 2].endLine;
              location_stack[tos - 1].endColumn = location_stack[tos + rhs[r] - 2].endColumn;
              location_stack[tos] = location_stack[tos + rhs[r] - 1];
          }
        }

      else
        {
          if (saved_yytoken == -1 && automatic (lexer, yytoken) && t_action (state, T_AUTOMATIC_SEMICOLON) > 0)
            {
              saved_yytoken = yytoken;
              yytoken = T_SEMICOLON;
              continue;
            }

          else if ((state == INITIAL_STATE) && (yytoken == 0)) {
              // accept empty input
              yytoken = T_SEMICOLON;
              continue;
          }

          int ers = state;
          int shifts = 0;
          int reduces = 0;
          int expected_tokens [3];
          for (int tk = 0; tk < TERMINAL_COUNT; ++tk)
            {
              int k = t_action (ers, tk);

              if (! k)
                continue;
              else if (k < 0)
                ++reduces;
              else if (spell [tk])
                {
                  if (shifts < 3)
                    expected_tokens [shifts] = tk;
                  ++shifts;
                }
            }

          error_message.clear ();
          if (shifts && shifts < 3)
            {
              bool first = true;

              for (int s = 0; s < shifts; ++s)
                {
                  if (first)
                    //: Beginning of the string that contains
                    //: comma-separated list of expected tokens
                    error_message += LU::tr("Expected ");
                  else
                    error_message += QLatin1String (", ");

                  first = false;
                  error_message += QLatin1String("`");
                  error_message += QLatin1String (spell [expected_tokens [s]]);
                  error_message += QLatin1String("'");
                }
            }

          if (error_message.isEmpty())
              error_message = lexer->errorMessage();

          error_lineno = lexer->startLineNo();
          error_column = lexer->startColumnNo();

          return false;
        }
    }

    return false;
}

std::ostream &QScriptParser::yyMsg(int line)
{
    return std::cerr << qPrintable(fileName()) << ':' << (line ? line : lexer->startLineNo()) << ": ";
}

void QScriptParser::processComment(const QChar *chars, int length)
{
    if (!length)
        return;
    // Try to match the logic of the C++ parser.
    if (*chars == QLatin1Char(':') && chars[1].isSpace()) {
        extracomment += QString(chars+2, length-2);
    } else if (*chars == QLatin1Char('=') && chars[1].isSpace()) {
        msgid = QString(chars+2, length-2).simplified();
    } else if (*chars == QLatin1Char('~') && chars[1].isSpace()) {
        QString text = QString(chars+2, length-2).trimmed();
        int k = text.indexOf(QLatin1Char(' '));
        if (k > -1)
            extra.insert(text.left(k), text.mid(k + 1).trimmed());
    } else if (*chars == QLatin1Char('%') && chars[1].isSpace()) {
        sourcetext.reserve(sourcetext.length() + length-2);
        ushort *ptr = (ushort *)sourcetext.data() + sourcetext.length();
        int p = 2, c;
        forever {
            if (p >= length)
                break;
            c = chars[p++].unicode();
            if (isspace(c))
                continue;
            if (c != '"') {
                yyMsg() << qPrintable(LU::tr("Unexpected character in meta string\n"));
                break;
            }
            forever {
                if (p >= length) {
                  whoops:
                    yyMsg() << qPrintable(LU::tr("Unterminated meta string\n"));
                    break;
                }
                c = chars[p++].unicode();
                if (c == '"')
                    break;
                if (c == '\\') {
                    if (p >= length)
                        goto whoops;
                    c = chars[p++].unicode();
                    if (c == '\n')
                        goto whoops;
                    *ptr++ = '\\';
                }
                *ptr++ = c;
            }
        }
        sourcetext.resize(ptr - (ushort *)sourcetext.data());
    } else {
        int idx = 0;
        ushort c;
        while ((c = chars[idx].unicode()) == ' ' || c == '\t' || c == '\n')
            ++idx;
        if (!memcmp(chars + idx, MagicComment.unicode(), MagicComment.length() * 2)) {
            idx += MagicComment.length();
            QString comment = QString(chars + idx, length - idx).simplified();
            int k = comment.indexOf(QLatin1Char(' '));
            if (k == -1) {
                trcontext = comment;
            } else {
                trcontext = comment.left(k);
                comment.remove(0, k + 1);
                TranslatorMessage msg(
                        trcontext, QString(),
                        comment, QString(),
                        fileName(), lexer->startLineNo(), QStringList(),
                        TranslatorMessage::Finished, /*plural=*/false);
                msg.setExtraComment(extracomment.simplified());
                extracomment.clear();
                translator->append(msg);
                translator->setExtras(extra);
                extra.clear();
            }
        }
    }
}


bool loadQScript(Translator &translator, const QString &filename, ConversionData &cd)
{
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly)) {
        cd.appendError(LU::tr("Cannot open %1: %2").arg(filename, file.errorString()));
        return false;
    }
    QTextStream ts(&file);
    QByteArray codecName;
    if (!cd.m_codecForSource.isEmpty())
        codecName = cd.m_codecForSource;
    else
        codecName = translator.codecName(); // Just because it should be latin1 already
    ts.setCodec(QTextCodec::codecForName(codecName));
    ts.setAutoDetectUnicode(true);

    QString code = ts.readAll();
    QScriptParser parser;
    QScript::Lexer lexer(&parser);
    lexer.setCode(code, filename, /*lineNumber=*/1);
    parser.setLexer(&lexer);
    parser.setTranslator(&translator);
    if (!parser.parse()) {
        std::cerr << qPrintable(filename) << ':' << parser.errorLineNumber() << ": "
                  << qPrintable(parser.errorMessage()) << std::endl;
        return false;
    }

    // Java uses UTF-16 internally and Jambi makes UTF-8 for tr() purposes of it.
    translator.setCodecName("UTF-8");
    return true;
}

QT_END_NAMESPACE

#endif // QSCRIPT_CPP
